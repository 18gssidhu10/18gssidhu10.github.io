# Modding In-Game Properties Of Super Mario Bros. through Game Genie Codes

![voorkant cropped pws](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/41d72ddd-5857-483f-b1a2-7d8a74d6679a)

## Inleiding

Hoe kwam ik op het idee om dit te doen?

Ik hield al van vroegs af aan van games. Ik herinner me nog duidelijk toen mijn vader kwam met een Limited Edition Mario Kart Wii  + Wii bundel. Ik was toen ongeveer 5 jaar oud. Sindsdien speel ik mijn hele leven al Wii Games. Ik kwam pas achter van mods/ROM Hacks toen ik 10 was toen mijn vader een rom hack had gedownload voor New Super Mario Bros. Wii. De game was Newer Super Mario Bros. Wii. Als tienjarige was ik gefascineerd hoe er nieuwe personages en eigenschappen waren, bijvoorbeeld de Hammer Suit als Power-Up  en Shy Guys als enemies etc.
Jammer genoeg mocht ik niet meer op de Wii spelen waardoor ik een break van 3 jaar had. Ik begon weer met console gaming toen ik op YouTube een kanaal had gevonden genaamd Mayro die NSMBW (New Super Mario Bros. Wii mods liet zien en speelde. Ik zag dat Mayro op PC speelde en sinds ik ook een PC had, dacht ik dat ik het ook kon. Ik zocht op hoe dat kon en vond uit wat een emulator is. Ik downloadde de emulator en de game en probeerde het te spelen. 
Jammer genoeg had ik een erg slechte PC, waardoor het de hele tijd rond 0-0,1 FPS zat. 

Toen ik in de derde zat, kreeg ik een laptop om lessen online te kunnen volgen (de pandemie begon toen) waardoor ik nu wel op de emulator Wii games kon spelen. Ik begon eerst met de vanilla games, maar kwam al snel in de modding en speedrunning scene terecht en was erg geïnteresseerd in het modden van de game zelf. Ik had hiervoor Super Mario World levels gemaakt met een level maker, maar dat was voor een korte tijd, omdat ik niet echt hield van de game mechanics. Ik begon dus met het maken van een ROM Hack voor NSMBW. Mijn plan was om elke enemy te veranderen naar Lemmy, een boss uit wereld drie die ballen gooit die stuiteren. Ik maakte dit en vond het best wel leuk, maar ik kreeg een operatie in de derde waardoor ik niet verder kon. Ik ben ook nooit verder gegaan, maar ik ben wel van plan om dat (ooit) te doen. Na mijn operatie speelde ik vooral Mario Kart Wii en Inazuma Eleven Go Strikers 2013. Ik modde de games, maar nu veranderde ik niet de gameplay, maar de graphics. Voorbeelden hiervan zijn characters uit andere series in Mario Kart Wii zetten, zoals Roronoa Zoro uit One Piece en voor Inazuma Eleven Go Strikers 2013 maakte ik kleurvariaties van de technieken en vertaalde ik Kanji naar het Engels of Nederlands.
Ik wou al sinds de tweede klas iets met game modding gaan doen voor mijn PWS, omdat ik van mijn zus hoorde dat zij raytracing deed en dat iedereen zelf een onderwerp mocht kiezen. Ik besloot dus toen al om iets te doen met het modificeren van games, maar welke game zal ik modificeren?

### Welke game kies ik?

Ik heb voor de game Super Mario Bros. gekozen, wat wellicht 1 van de meest populaire en iconische games aller tijden is. SMB was uitgebracht als eerste in Japan op 13 september 1985 en hetzelfde jaar in Amerika. Oceanië en Europa kregen de game pas 2 jaar later binnen. Wat maakte de game nou eigenlijk zo speciaal en hoe werkt de game? Super Mario Bros is een spel waarbij een Italiaanse man genaamd Mario een princess genaamd Peach gaat redden van de schurk Bowser. Dit is een simpel concept, maar de uitwerking van dit spel was voor die tijd revolutionair. Van de graphics tot de gameplay was alles erg verschillend. Het is een erg simpel concept maar erg goed uitgewerkt. Dit zorgde ervoor dat de game erg populair werd en mensen tot op de dag van vandaag nog steeds de game spelen. Wat ook een grote rol bij de populariteit van de game speelt is dat er in de jaren tachtig een crash was van de gaming markt. De gamingmarkt zat toen vol ‘low-budget games’. low-budget games zijn vaak games die goedkoop zijn die niet innovatief waren en vaak slecht gemaakt. Dit soort games namen de markt over, waardoor de markt niet meer stabiel was. Super Mario Bros. was de doorbraak voor deze crash. Wie weet wat er met de gaming industrie zou gebeuren als Nintendo niet iets innovatiefs uitbracht zoals Super Mario Bros.

### Waarom kies ik voor Super Mario Bros.?

Ik heb voor Super Mario Bros. gekozen voor een paar redenen:

1) Ik ben een erg groot fan van Mario games en wou meer willen weten over de originele game en hoe de eerste game voelt vergeleken met 20 tot 30 jaren later? 

2) Er is erg veel informatie over de game zelf, aangezien het zo een populaire game is. Wij hebben heel veel informatie over de game en weten eigenlijk alles over de game zelf. Dit komt voornamelijk door de Speedrunning community.
Speedrunnen is het zo snel en efficiënt mogelijk voltooien van een game of een deel van een game. Om Super Mario Bros. uitgespeeld te hebben, moet je Bowser verslaan. Bowser is in Wereld 8 in het laatste level oftewel 8-4 waarbij het eerste getal voor de wereld staat waar je in speelt en het laatste level voor welk level het is. Er zijn in elke wereld (van 1 tot en met 8) 4 levels. Er zijn dus 32 levels in totaal. Om al deze levels te voltooien en uiteindelijk bij Bowser te komen en hem te verslaan, duurt het de gemiddelde persoon 2 uur. Dit is dus een normale playthrough en geen speedrun, maar hoelang doet de beste speedrunner erover? 

Het antwoord is 4 minuten, 54 seconden en 631 milliseconden. Dit betekent dus dat de beste speedrunner ongeveer 65 minuten sneller is! Je vraagt je nu vast af hoe dat kan. Om de game zo snel mogelijk uit te spelen moet je dus erg snel zijn en zo min mogelijk levels willen spelen en hier komen shortcuts van te pas. Shortcuts zijn in Super Mario Bros. verborgen ruimtes waar je naar een andere wereld kan gaan.

![SMB_Warpzone](https://github.com/18gssidhu10/18gssidhu/assets/151066156/d29f32a2-5885-4608-8dea-ed3b3ad6b3ad)

Zoals je hierboven in het plaatje kunt zien staat dat wij in wereld 1 zijn en het tweede level. Je kan hier dus naar Wereld twee, drie of vier gaan. Als je wereld twee kiest, sla je twee levels over, namelijk 1-3 en 1-4. Als je wereld drie kiest, sla je 1-3, 1-4 en heel wereld 2 over. Dit zijn dus 6 levels. Als je wereld vier kiest, sla je dus 1-3, 1-4, wereld 2 en wereld 3 over. Je slaat dus 10 levels over. Als speedrunner wil je zo snel mogelijk de game uitspelen, dus je kiest uiteraard voor warp (de pijp) 4. Dit soort verborgen ruimtes, waar je naar een andere wereld kan gaan, heten ‘Warp Zones’. 
Wat handig is, is dat je in 4-2 ook een warp zone hebt. Dit zou betekenen dat je naar wereld vijf, zes of zeven zou kunnen gaan. Dit is echter niet het geval.

![Super Mario Bros (JU) (PRG 0)-0](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/fdee48c5-2cfa-4cff-b180-28a1ff5f4e68)

Zoals je hier ziet zie je wereld zes, zeven en acht als optie, maar geen 5. Dit is voor een speedrunner erg handig, omdat hij nu 14 levels (4-3,4-3, W5, W6, W7) erbij kan overslaan.
Je kan dus in totaal 14 + 10 = 24 levels overslaan. Je moet dus 32 - 24 = 8 levels spelen om de game uit te spelen. Als 32 levels spelen ongeveer 120 minuten duurt, betekent het dus dat elke level 3 minuten en 40 seconden duurt. Doe dat keer het aantal levels dat je moet spelen om de game uit te spelen en je krijgt is 30 minuten. Hoe kan het dan dat er nog van die 30 minuten er 25 minuten van afgaan?

Hier komen glitches van te pas. Glitches zijn foutjes in de game code die ervoor zorgen dat er dingen in de game gebeuren die eigenlijk niet zouden gebeuren en niet de intentie was van de ontwikkelaar van de game. Een goed voorbeeld hiervan is het manipuleren van de timer wanneer je de vlag hebt bereikt. Wanneer je de vlag hebt bereikt moet de resterende tijd omlaag gaan naar 0 en opgeteld worden bij je score. Dit duurt best wel lang en speedrunners wouden een manier vinden om dat te manipuleren. Zij hebben hier, door middel van een glitch, ervoor gezorgd dat als je een pixel-perfect jump hebt op de flagpole, dat de timer niet tot 0 gaat en opgeteld wordt bij je score als je aan het wachten bent. In plaats daarvan ga je nadat Mario naar het eindkasteel bij een level is gekomen meteen naar het volgende level zonder delays (bij alle levels die geen castle (X-4) levels zijn.

![EmzlQ](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/01525144-3a4d-4363-9af2-bb7ae478fadf)
![sidebysideflagpole glitch (1)](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/ef7689f0-24fd-4646-8239-86877fac015d)


**_De 'Flagpole Glitch' en vergeleken met de normale manier_**

Dit is 1 van de vele optimizations die speedrunners hebben gevonden. De speedrunners hebben dit gevonden door de code van de game en de eigenschappen van de game te onderzoeken. Wij zijn zelfs zo ver dat wij bijna de menselijke limiet hebben bereikt voor hoe snel je de game kan uitspelen. Dit zou natuurlijk nooit kunnen als er geen onderzoek werd gedaan naar de game zelf en als de game niet zo populair was. Dit is dus voor mij erg handig, omdat ik de onderzoeken naar de game van de speedrunners kan gebruiken om de eigenschappen van de game te snappen en zelf de eigenschappen te veranderen door middel van cheat codes. 

### Wat zijn cheat codes?

Cheat codes is een verzamelnaam voor een stukje code of bepaalde inputs die ervoor zorgen dat bepaalde eigenschappen in een game veranderen. Dit maakt heel vaak de game makkelijker dan de originele game. Denk hierbij aan oneindig veel levens, power-ups krijgen, niet geraakt kunnen worden door enemies etc. De eerste cheat codes werden vaak gebruikt door de ontwikkelaars zelf om te kijken of de game niet al te lastig was. Later werden cheat codes gemaakt door de speler zelf, omdat vaak ontwikkelaars de cheat codes niet uitgaven aan de spelers. De eerste populaire cheat code was voor de erg populaire game genaamd Gradius. De game ontwikkelaar vond de game bij het ontwikkelen zo lastig dat het hem niet eens lukte om zijn eigen levels te halen. Hij heeft daardoor een code bedacht die hij makkelijk kan herinneren. Dit stukje code was een bepaalde reeks van inputs. Dit was:
Up, up, down, down, left, right, left, right, B, A, start. Deze reeks van inputs zorgde ervoor dat je elke power-up kreeg, waardoor de game vele malen makkelijker werd. Wat ook grappig is, is dat deze cheat code ook werkte bij sommige andere games zoals Castlevania waardoor je 50 levens kreeg. Dit was de eerste keer dat cheat codes bekend werden. De Konami Code, vernoemd naar de uitgever van de game die de cheat code had, werd populair en dit zorgde ervoor dat gamers meer cheat codes wilden en zelf gingen zoeken naar cheat codes. Hedendaags zien we dat dit nog steeds gebeurt, maar niet meer zo veel aangezien maar weinig mainstream games lastig zijn. Er zijn wel modificaties van games die ervoor zorgen dat eigenschappen van games worden veranderd. Cheat codes zijn soms dus nog steeds relevant. 

### Wat is een game genie?

Om cheat codes te maken zal ik de game genie gebruiken. De game genie is om het simpel te maken een extensie voor een NES cartridge die cheat codes heeft voor populaire games. De Game Genie werd gemaakt door het bedrijf Codemasters, die zich gevestigd had in het Verenigd Koninkrijk. De naam kan bekend zijn bij sommigen, omdat Codemasters nu deel is van Electronic Arts en ze nu F1 games maken. 
 De Game Genie was niet hun eerste product voor de NES. Ze hadden namelijk al zelf games voor de NES games gemaakt die niet gelicenseerd waren zoals The Fantastic Adventures of Dizzy, Firehawk etc.


Nadat Codemasters de game genie had ontworpen gelicenseerde de game genie eerst aan Camerica en daarna aan Galoob. Camerica is een Canadese bedrijf  dat ook ongelicenseerde games verkocht waaronder die van Codemasters. Camerica was de uitgever voor de game genie in Canada en Galoob voor de Verenigde Staten. Het uitgeven van dit product ging natuurlijk niet zo makkelijk. Nintendo was ook toen erg streng als het ging om producten die Nintendo’s producten ‘gebruikten’. Nintendo klaagde Camerica eerst aan en gebruikte als argument dat het ‘een schending van hun auteursrecht is’. Gelukkig was dat al snel afgewezen door de rechtbank en kon Camerica eindelijk de game genie releasen. De aanklaging op Galoob duurde iets langer en was niet hetzelfde als in Canada waardoor de release van de game genie in de VS later was dan die van in Canada. Dit komt omdat Galoob allegedly aan Nintendo vroeg om dit een officieel product te maken en dat Nintendo hen afgewezen heeft. Nadat Nintendo hen had afgewezen, ging Galoob toch proberen om het te verlenen, maar toen klaagde Nintendo galoob aan. Howard Lincoln, Nintendo’s  vicepresident, zei dit over de game genie: `It creates derivative works. It not only alters Nintendo games, infringing on copyright, but can make them less fun, too easy to play.’’ Als tegenargument zei Steven Klein, de vicepresident van Galoob, dit: “Is just like a book. If you want to start at Chapter 11, you can. If the kid wants to start at World 8, because he’s been through all the earlier levels before and doesn't want to spend an hour doing it again, why shouldn’t he be able to?” Dit is wel iets waar ik het mee eens ben met Steven Klein, omdat er toen amper games waren met dingen zoals savestates. Dit komt mede dankzij het kleine aantal kilobytes dat de cartridge kon hebben. Natuurlijk zou dit argument nu niet echt kloppen, omdat wij dit soort problemen niet meer hebben, maar omdat het dus een heel ander verhaal was in die tijd was er nog veel discussie over. De rechtbank was uiteindelijk voor Galoob en de Game Genie mocht dus verkocht worden in de VS. De rechtbank had als argument dat er fair use was, omdat de consument als de game had gekocht, waardoor de consument dus onder de fair use zit en je de game dus mag modden. En de game genie mod(t?) de game dus het is toegestaan. De Game Genie was dus best wel belangrijk voor de regels van fair use en copyright infringement.

Het opvallende aan de game genie is hoe de game genie eigenlijk gemarket werd. Het is natuurlijk een accessoire die de game modt door middel van cheat codes in de vorm van letters, maar het werd verkocht als een ‘video game enhancer’ die het meeste uit je game haalt. Dit is natuurlijk een erg handige strategie, omdat cheat codes heel vaak een negatieve indruk geven en het gevoel geeft alsof het product illegaal is(wat het ook bijna was aangezien Nintendo hen aanklaagde). 
De Game Genie kwam in een doos waarin 2 dingen zaten; de game genie zelf en een handleiding. Ik zal eerst iets vertellen over de handleiding. 
In de handleiding van de game genie stond hoe je de game genie moet gebruiken,  de codes voor de populaire games die werden uitgebracht en hoe je zelf game genie codes kan maken. Dit is erg interessant, omdat zij dus eigenlijk willen dat jij zelf probeert jouw eigen codes te maken. Natuurlijk konden zij niet een uitgebreide uitleg geven van hoe een game genie precies werkt, maar hadden ze de volgende twee  methodes opgegeven:

1) Verander van een bestaande  code die in de handleiding staat de **eerste** of **tweede** letter van de cheat code. 

2) Verander van een bestaande code die in de handleiding staat de **eerste**  of **laatste** letter van de cheat code.

   
Zij geven ook voorbeelden van cheat codes die je kan veranderen en geven tabellen van welke letters in welke letters kunnen veranderen.(hier ga ik dus fotos bijzetten met meer uitleg erover maar denk dat handiger is om de dat in de site te zetten)
Een terechte vraag die je nu kan stellen is hoe ze de codes voor nieuwe games uitgeven aan de consument zonder de inhoud van de doos te veranderen. Dit deden ze erg slim. Ze hadden op de laatste bladzijde van de handleiding een advertentie geplaatst waarop staat dat als je nieuwe codes wilt van nieuwe games, je een subscription moet kopen om de codebooks te krijgen. Die codebooks komen dan vier keer  per jaar van de nieuwste games die dat jaar werden uitgebracht. Dit kostte rond de $3,50 was rond die tijd (omgerekend naar nu is het rond de $7,50).
 Rond deze tijd kocht Galoob de game genie licentie van Camerica, omdat Camerica zich meer wilde focussen op het maken van hun eigen games. Galoob had dus nu ook de rechten voor de game genie in Canada.  De game genie stopte met de productie rond 1998 doordat Galoob werd gekocht door Hasbro, de daling van populariteit en doordat er een nieuwe generatie consoles kwamen, want de consoles die een game genie hadden zijn: De NES, Sega Genesis, Sega Game Gear,  Game Boy en de SNES. Maar wat zijn consoles nou eigenlijk?

### Wat is een console? De geschiedenis van consoles

Een console is een hardware apparaat waar je games op kan spelen. De beroemdste consoles zijn de Playstation, Xbox, Nintendo Switch etc. Consoles waren 50 jaar geleden vele malen slechter. De populairste manier om games te spelen voor 1980 was door middel van arcade machines. Arcade machines zijn apparaten die speciaal werden gemaakt om erop te gamen. Je kon ze in arcadehallen vinden, winkelcentra etc. In de jaren 80 wilde men dat gaming in plaats van buiten huis om, ook binnen het huis kon worden gespeeld. Zoals ik al eerder zei, is dit de tijd van ‘The Great Video Game Crash of 1983’. Iedereen probeerde in die tijd een apparaat te maken waarmee je thuis games kan spelen; een console. Omdat zo veel bedrijven consoles maakten, was er veel concurrentie. Iedereen wou dus zo snel mogelijk het af hebben, zodat zij de eerste zijn. Dit hebben ze ook gedaan met de games. Er waren dus veel te veel consoles om uit te kiezen en de games op al die verschillende consoles waren ook niet innovatief en goed qua game development. Doordat het zo een slechte markt werd, dachten sommige mensen zelfs dat de gaming industrie niet meer zal bestaan, maar toen kwam de console van Nintendo: The Nintendo Entertainment System. 

### Geschiedenis NES/ Hoe werkt de NES?

De NES leek niet op een console en gebruikte ook niet de termen video game, zodat het niet die slechte reputatie zou krijgen. Je kreeg er twee controllers bij, zodat het echt leek op een entertainend iets wat je met je familie kan spelen in de woonkamer. De NES was revolutionair door zijn nieuwe technologie voor die tijd. Het had:

1) 1,7 megahertz processor
2) 2 kilobytes aan RAM
3) een maximale resolutie van 240p

Een processor, ook wel CPU (Central Processing Unit) genoemd,  is het hart en brein van de console. De processor doet alle berekeningen, bewerkt alle gegevens, beheer van registers waar informatie opstaat, en het uitvoeren van instructies. De RAM, Random Access Memory, is het tijdelijke geheugen van de console. Het slaat dus de tijdelijke  toestanden van de game op als je speelt . Verder zorgt ervoor dat alle gegevens die nodig zijn snel geladen en verwerkt worden. Alle in-game eigenschappen die een waarde kunnen hebben, terwijl je het spel aan het spelen bent, zitten in de RAM. 
De resolutie is het maximale aantal pixels dat je kan hebben op je scherm.

Dit is natuurlijk erg laag voor ons, omdat wij gewend zijn aan veel betere technologie, maar in die tijd was dit vele malen beter dan de Atari 2600 bijvoorbeeld, die voordat de NES bestond erg populair was. De NES was revolutionair en begon aan een nieuwe generatie van consoles. Verder was de prijs van de NES best wel, want kostte maar 250 dollar als je het omrekent naar het heden. Al deze factoren zorgden ervoor dat dit een grote hit werd. De NES is in totaal 61,9 miljoen  keer verkocht, wat voor die tijd de meeste was in de geschiedenis van consoles. Door deze boost bleef Nintendo verder consoles maken en zij zijn daar nog steeds mee bezig. De Nintendo Switch is nu hun mainstream console en de Switch is al meer dan 125 miljoen keer gekocht. De specs vergeleken met de NES zijn ook verbazingwekkend. Het vermogen van de Switch is ongeveer 370.000 keer zo sterk als de NES! 
De NES heeft niet veel geheugen, dus dit betekent dat er niet zo veel code is en het dus veel makkelijker is om in-game eigenschappen in de code te detecteren vergeleken met een console zoals de Switch, die letterlijk twee miljoen keer zoveel geheugen aankan!
Het feit dat Super Mario Bros. een erg populaire game is met veel informatie in combinatie met een console waarbij het makkelijker is om in-game eigenschappen te veranderen hebben ervoor gezorgd dat ik dit als mijn onderzoeksvraag heb:

**_Kan je met een NES Game Genie een eigen cheat code vinden voor Super Mario Bros. op de Nintendo Entertainment System?_**

#### Motivatie onderwerp

Dit onderwerp is erg relevant voor mij, omdat ik Computer Science ga studeren. Met een Computer Science bachelor en master degree kan je veel richtingen op, waaronder de gaming industrie als Game Developer. Ik hou erg veel van games en wil dus ook weten of het een geschikte baan is voor mij en of ik het wel leuk vind om dit soort dingen te doen. Dit is dus voor mij een middel om te kijken of een game engineer iets voor mij is. 

#### Hypothese

Ik denk dat het wel mogelijk zal zijn en het ook zal lukken om cheat codes te maken dmv de game genie, omdat ik erg veel bronnen en voorbeelden heb die ervoor kunnen zorgen dat het mij wel gaat lukken.Verder heb ik ook platforms zoals reddit en discord die mij kunnen helpen wanneer ik vastzit. Het enige probleem is hoe goed de cheat code werkt en dat er geen side effects zijn . 
Het onderzoek dat ik ga doen is dus kijken of ik zelf een game genie code kan maken die werkt en dat ik snap hoe het werkt. Ik denk dat het experiment goed zal komen als ik het goed genoeg voorbereid.

# Literatuurstudie

Hoe werkt de game genie eigenlijk? De simpelste manier om het uit te leggen is dat het de gegevens van de game opvangt, verandert en dat vertelt aan de console. Het is dus een soort van middleman. (voorbeeld geven dmv plaatje maar dat komt later dus)
Het is een middleman tussen de processor, oftewel de console en de Read Only Memory (ROM) data, oftewel de cartridge waar de game zelf in zit. Hoe elke game werkt is dus via de processor en de ROM data. wanneer de processor iets moet lezen of uitvoeren van de  rom, dan  wordt de waarde die is opgeslagen op de cartridge op de gespecificeerde locatie 
gekopieerd naar een soort  intern register. Wat de game genie doet is het lezen van elke ROM waarde en als het correspondeert met de waarde van de cheat code  het te veranderen naar de waarde die de cheat code wil. Elke code kan alleen maar 1 waarde veranderen van het interne register. Als ik een game genie code wil maken, moet ik ervoor zorgen dat ik de ROM waarde kan veranderen en sinds de ROM waarde in hex code is  moet ik een stukje van die hex code hebben om een game genie code te maken.  Ik heb er uitgebreid naar gezocht en heb erg veel decoders gevonden, maar niet erg veel encoders gevonden om dat te doen. Ik heb ze gevonden door een Discord User in de Discord Server ‘SMB Arena’. De user heeft zelf ook erg veel ervaring met het maken van Game Genie codes en die gaf mij de volgende methodes.
Er zijn **Vier** verschillende methodes die je kan gebruiken om cheat codes te maken door middel van game genie codes. 

####  Gebruik maken van RAM Maps
Een RAM Map is een lijst met alle variabelen van een game. Je hebt een Address in de RAM en de informatie hierover (voorbeelden geven hiervan dmv fotos/film. dan zie je ook dat de values veranderen in de  hex editor). Al deze verschillende variabelen die veranderen make de RAM (Random Access Memory). Maar zoals ik al bij de literatuurstudie zei is het de ROM waar de game genie iets verandert dus wat heb je nou eigenlijk aan de RAM? Het zit zo: De ROM zegt wat de RAM moet doen en de RAM zegt wat de game moet doen. Dit is ook volkomen logisch, wat als de RAM dus de hele tijd verandert waarbij er meerdere mogelijkheden zijn (voorbeeld van enemies in dezelfde memory in ram) dan is het niet mogelijk om die te veranderen. RAM Maps bestaan vooral bij games die erg populair zijn zoals The Legend of Zelda en in mijn geval Super Mario Bros. De RAM Map die ik heb gebruikt telt alleen voor de JU versie dus die gebruik ik (zie materiaal)  Dit zijn de stappen hoe je een cheat code moet maken voor methode 1: (hier wil ik videovoorbeeld geven)

1) Zoek in de RAM Map een waarde die je zou willen veranderen. 

2) Kijk of die meerdere values heeft op dezelfde Memory slot

3) Open de Game in FCEUX en ga naar Debug -> Hex Editor

4) Kijk of je value correspondeert met wat er gebeurt in de game zelf

5) Als dit zo is, klik je rechtermuisknop op het stukje memory wat je wil veranderen en klik je op Add write breakpoint for Address X waarbij X de variabele is oftewel je waarde. Hierbij opent de debugger vanzelf.

Een write breakpoint is een plek in je programma die ervoor zorgt dat je makkelijker data en structuren kan vinden zodat je het programma beter kan onderzoeken en dat is perfect voor ons aangezien wij dat juist willen onderzoeken.
De debugger laat, om het simpel te maken, zien waar de RAM zit in de ROM oftewel waar de waarde in de ROM staat en waar je het echt moet veranderen om een game genie code te maken.
Vanaf nu wordt het een beetje lastig aangezien er heel veel verschillende mogelijkheden zijn. Dit zijn de belangrijkste mogelijkheden:

1. `CMP`: CoMPare accumulator 

2. `DEC`: DECrement memory 

3. `INC`: INCrement memory 

4. `LDA`: LoaD Accumulator 

5. `STA`: STore Accumulator 

De andere mogelijkheden staan in het hoofdstuk 6502 Assembly Language
Welke eigenschap je wil veranderen hangt erg af van welke waarde je wil veranderen 

6) Probeer of de opcode te veranderen of de waarde van wat de opcode verandert

7) Gebruik de Game Genie encoder door of op debugger -> game genie encoder/decoder of rechtermuisknop van address van rom create game genie code.

8) Compare the value indien het nodig is

9) Zet de cheat code bij je cheat code lijst

10) Test het uit of het werkt

11) als het niet werkt begin dan weer bij stap 6

Dit is een methode waarbij je veel moet brainstormen omdat je heel veel verschillende mogelijkheden hebt en veel opties. Jij moet  dus zelf kijken welke het beste is en goed werkt. Het grootste deel wat je moet onderzoeken is het kiezen van wat je eigenlijk wil veranderen. Voor heel veel codes moet je de opcodes veranderen, maar aangezien er zo veel verschillende mogelijkheden zijn moet je goed snappen wat je wil en wat de opcodes kunnen doen. Natuurlijk is het mogelijk om het te gokken, maar ik raad dat af, omdat het erg lang duurt en je er amper iets van leert en dan dus zelf ook niet snapt wat je hebt gedaan.

#### Een uitgebreide disassembly van de game 

Een uitgebreide disassembly van een game gebruik je wanneer je een erg complexe cheatcode wil gaan maken om bijvoorbeeld iets kleins of specifiek te doen wat normaliter dus niet kan bij RAM Maps. Hier zoek je dus voor iets specifiek, dus bijvoorbeeld hoe een blooper beweegt. Deze beweging kan je niet vinden in de RAM Map, maar wel in de disassembly. Deze manier gaat net als de RAM MAP. Je zal niet vaak een disassembly van een game zien, omdat het erg veel werk is. Je ziet disassembly vaak bij grote en populaire games. 

#### RAM Searching

Deze methode is niet erg efficiënt is heel vaak voor games die niet veel mensen kennen en waarvoor geen ram map of disassembly is. Bij de RAM search moet je kijken waar RAM addresses overeenkomen met wat jij wil. Stel je voor dat je wilt dat de vuurballengte minder moet worden. Je zal dan moeten aannemen dat het dus steeds omlaag gaat. Wanneer mario een fire flower heeft en een vuurbal gooit, moet je zsm de game op pauze zetten en de ram search zetten op kleiner dan, omdat je dus aanneemt dat het omlaag gaat . Unpause the game en pause the game weer totdat je maar 1 RAM Address vindt. Dit is de code die het dus ervoor zorgt. Herhaal weer stap 6 t/m 11 van methode 1 en je hebt je cheat code. 


#### Random getallen invoeren en hopen dat het lukt

Dit is by far de minst efficiënte manier en dit komt omdat het net als RAM Searching veel te lang duurt. Het feit dat je elke letter in een andere letter kan veranderen in een andere letter zorgt ervoor dat er te veel mogelijkheden zijn en je weet zelf niet eens welke letter wat verandert. Het maximaal aantal codes wat je kan maken is 26^8 en als je een bestaande code neemt zijn het er nog steeds 26x26 (zoals de handleiding van de Game Genie zei over eerste, tweede of laatste letter veranderen) = 676 verschillende mogelijkheden. Dit is dus niet een optie die je eigenlijk moet gebruiken als er geen andere mogelijkheid is.


Ik zal zelf meer methode 1 en 2 gebruiken, omdat die het meest efficiënt en handigst zijn. 



# Materiaal 

De materialen die je nodig hebt zijn:

1) Een **PC** of **Laptop**. De Operating System maakt hier niet uit, aangezien de emulator FCEUX compatible is met elke OS. Je hebt minimaal een 32-bit processor nodig. Verder is er niet veel nodig. Zelfs een schoolcomputer kan deze software aan.

2) **FCEUX64 2.6.5**. Dit is een NES emulator die erg handig is, omdat die een game genie encoder/decoder heeft, debugger, hex editor en nog veel meer. Hij heeft dus veel meer mogelijkheden vergeleken met andere emulators zoals Nestopia.

3) **Super Mario Bros (JU) (PRG 0).nes**.  Dit is de Japanse game file van Super Mario Bros. De game file kan je vrij makkelijk op het internet vinden en aangezien de game ongeveer 50 jaar geleden is uitgebracht, heeft Nintendo niemand recent aangeklaagd voor piracy als het gaat om Super Mario Bros. voor de NES. Voor de zekerheid heb ik een cartridge van Super Mario Bros, de fysieke variant, voor de zekerheid. Ik raad het aan om er eentje te kopen, als je bang bent dat Nintendo je zal gaan aanklagen.

Dit is stapsgewijs de methode die ik heb gebruikt. 


# Methode

De methode die ik heb gebruikt is een combinatie van methode 1 en 2 waarbij ik vooral de RAM Map heb gebruikt en bij sommige cheat codes de disassembly.  
Dit is stapsgewijs de methode die ik heb gebruikt.  

1) zoek in de RAM Map welke in-game property je wil veranderen. Als je iets wil veranderen wat niet in de RAM Map zit, ga dan naar de disassembly van de game.

2) Als de eigenschap die je wilt veranderen daar staat, ziet het er als volgt uit:

![Schermafbeelding 2023-11-26 193811](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/b7cefeac-9a97-4bf1-8275-2799134756d3)


3) Nadat je de RAM Address hebt gevonden van de eigenschap die je wil veranderen,  open je FCEUX

![573eec40e4ef4f2089531dd5cbf629f8](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/65ae018a-83cb-4a9e-8b8b-4483168bf071)
       **_Het logo van FCEUX_**

4) Open het bestand van je game (File -> Open -> "De directory van de game"

![Schermafbeelding 2023-11-26 195803](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/2124d77b-e1ac-432b-adb7-83d5d6d44205)

5) Open de ga Hex Editor (Debug -> Hex Editor...)

![Schermafbeelding 2023-11-26 195955](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/3227b79b-3792-4e80-8c8c-1d38e54a1804)

![Schermafbeelding 2023-11-26 200451](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/331b4533-50b4-4052-a0c7-a33778eca34f)

**_De Hex Editor ziet er zo uit. Links zie je de address en in het midden de waarden_**

![Schermafbeelding 2023-11-26 200451(1)](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/2c7a078d-11a3-41ce-82d6-921686ce6839)

**_Als je address `0x0057` is, dan zie je dat het de waarde E8 is en bij `0x008B` 80_**

6) Als je de hex editor open hebt gemaakt, run je de game totdat de waarde van je eigenschap die je wou veranderen verandert. Dit doe je, omdat je zeker wil weten dat de value verandert alleen op de eigenschap die jij wil verandert en niet op iets anders

7) Nadat je hebt gecheckt of het de goede RAM Address is, ga je een toestand vinden waar die waarde verandert naar de eigenschap die jij wil en je zet de game op pauze als de eigenschap die je wil veranderen niet een tijdsperiode heeft. Daar zet je een writing breakpoint bij. Als je met je rechtermuisknop op de address klikt waar de waarde van jouw eigenschap verandert, dan krijg je dit te zien:

![Schermafbeelding 2023-11-26 204750](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/a9cdcbbc-7e91-456f-bbfe-d770d499beab)

8) Hier klik je op: Add Write Breakbpoint for Address X (in het geval van de afbeelding is het dus 10F8) 

9) Nadat je dit hebt gedaan, ga je weer de waarde van je property veranderen door de game nu normaal te spelen totdat de waarde verandert corresponderend met de Write Breakpoint. Als dat goed gaat opent de debugger vanzelf en krijg je dit te zien:

![debug (1)](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/c5a8f0a0-eb80-4386-8680-fd3546ac3830)

**_Het zwarte omringde is de ROM Address en linksboven de RAM Address die je als breakpoint gebruikt_**

Zoals al eerder is verteld veranderen Game Genie codes de waarde van de ROM en niet van de RAM. Als wij naar de Address gaan die daar staat, kom je dus je code tegen. Hier wordt het brainstormen, omdat je zelf moet kijken of je de opcode of de waarde wil veranderen. Vaak verander je de opcode en misschien verander je de opcode die daarvoor kwam, omdat er een correlatie tussen twee opcodes is. Dit is een lang proces van trial and error totdat je een goede oplossing hebt gevonden zodat wat je wilt veranderen ook zal veranderen. Bij de trial and error heb je de volgende stappen:

1) Kijk naar welke opcode het is. Dit kan je zien door middel van de Hexadecimale code waarin de Hex Editor is geschreven.  `95` staat voor een `STA` en om precies te zijn deze `STA: Zero Page,X   STA $44,X`. Elke opcde heeft verschillende soorten die hij kan aannemen en hierbij moet je ook zelf bedenken wat de beste optie is. Wat voor soort opcode het eerst was ie je ook in de debugger naast de ROM Address:

![Schermafbeelding 2023-11-27 015418](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/91730049-ca35-4d53-830e-4743e99bd0e4)

Hier zie je een waarde van vier cijfers. Als je naar de site gaat waarin alles over opcodes staat (http://www.6502.org/tutorials/6502opcodes#STA), zie je dit:

![Schermafbeelding 2023-11-27 015529](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/b52e8196-8c6f-46b5-bf91-331f66eef87d)

Dit zegt dus dat het hier een Store Accumulator is, die altijd een vaste waarde heeft. 
Bij alles wat je wil veranderen moet je dus goed opletten wat je kan en moet veranderen. 

2) Als je weet waar je de opcode of waarde naartoe wil veranderen, dan ga je weer terug naar de Hex Editor.

3) Klik in de Hex Editor op de address die je wilt veranderen. Je krijgt dit te zien:

![Schermafbeelding 2023-11-27 015648](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/27b6c1ab-aa97-4476-9ff4-0a50a7c0229b)

4) Klik op Create Game Genie Code At This Address.

5) Vul de address van het stukje in at je wou veranderen, en schrijf daaronder welke naar welke value je het wil veranderen en vergeleken met welke waarde als jouw eigenschap meerdere waardes kan hebben.

![Schermafbeelding 2023-11-27 015814](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/ecb17a68-5ed3-4e2d-b8bf-258649ddab24)

**_Dit is hoe de Game Genie Encoder/Decoder eruitziet. 
Bij Address: zet je de ROM address in.
Bij Compare: welke waarde in de address moet hij hebben voor de cheat code om te werken. 
Bij Value: waarin je de waarde wil veranderen op die address_**

6) Klik op Add To Cheat List

7) Reset de game en zorg ervoor dat cheats enabled zijn. (Tools -> Cheats)

![Schermafbeelding 2023-11-27 020320](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/a8718d9d-c740-4870-a458-87492542ab1d)

8) Kijk of je eigenschap is verandert hoe je het wilt hebben. Zo niet, ga dan terug naar stap 1 en probeer iets anders te vinden.


Dit is hoe ik elk van mijn game genie codes heb gemaakt. Ik zal video’s van de rundown van zo een cheat code maken laten zien bij de resultaten


# Resultaten

[![Watch the video](https://img.youtube.com/vi/-1fEDGuPKIg/maxresdefault.jpg))](https://youtu.be/-1fEDGuPKIg) 

[![Watch the video](https://img.youtube.com/vi/-1fEDGuPKIg/Schermafbeelding 2023-11-27 191604.jpg))](https://youtu.be/-1fEDGuPKIg) 




# Conculusie/Discussie

Voor een vervolgonderzoek zou ik ook graag de andere methodes willen proberen. Wat mij vooral interessant lijkt is om te kijken of ik zelf mijn cheat codes die ik heb gemaakt kan maken met de andere methodes. Dat is natuurlijk niet efficiënter, maar daarmee kan ik wel bewijzen dat het ook kan met de andere cheatcodes.

Wat verder voor een vervolgonderzoek zou kunnen en het hele proces efficiënter is, is het automatiseren van het proces. Dit kan door gebruik te maken van een scripting interface. Een scripting interface zorgt ervoor dat een handeling die je erg vaak moet doen, in mijn geval dus kijken welke opcodes werken, geautomatiseerd worden door middel van een script.
Wat ook interessant zou zijn is om game genie codes te maken voor games die niet zo populair zijn zodat ik alleen methode 3, oftewel ROM Searching, kan gebruiken. Als ik vragen heb over de game, dan kan het zo zijn dat mensen die mij hebben geholpen met Super Mario Bros amper weten hoe het met die game mechanics zit. Verder kan je bij sommige games (ook populaire) ROM Banking hebben. Dit soort ROMs heten Memory Mapped ROMs. ROM Banking zorgt ervoor dat er meer geheugen is dan er eigenlijk fysiek kon. De NES leest een deel van de ROM Address, een “Bank’’, die dan geladen zal worden. Wanneer een andere Bank nodig is, switcht hij naar de andere Bank. Hierdoor ontstaat er dus veel meer plek voor meer code.

Verder kan ik proberen game genie codes te maken voor andere consoles, aangezien de Game Genie ook gemaakt is voor andere consoles zoals de Sega Genesis, Sega Game Gear,  Game Boy en de SNES. De methode zal overal anders zijn behalve de SNES, omdat de SNES erg veel lijkt op de NES en de Game Genie ook op dezelfde manier de ROM verandert. Bij de andere consoles zou ik op zoek moeten gaan naar de emulators en kijken of de emulators een Hex Editor, Debugger en Game Genie Encoder/Decoder hebben. Als zij dat ook hebben, is het nog steeds lastig om Game Genie codes te maken, omdat de opslag vergeleken met de NES vele malen groter is. 

Ik heb zelf gemerkt dat sommige bronnen die ik heb gebruikt voor dit experiment niet dezelfde informatie geven over een bepaalde RAM Address. Dit was in het geval van de RAM Map ten opzichte van de Disassembly. De disassembly is namelijk veel duidelijker en gedetailleerder, terwijl de RAM Map vaak een vage beschrijving geeft van de RAM Address. Ik heb daarom ook altijd gecheckt of alles overeenkomt met de disassembly, omdat die ook door veel mensen in de community van de modding scene zeggen dat dit erg betrouwbaar is. Het is dus altijd handig om na te gaan bij meerdere bronnen of zij wel hetzelfde zeggen.


# 6502 Assembly Language 
## Refereren naar assembly en de opcodes

Super Mario Bros. is opgeschreven in de taal van Assembly en om precies te zijn 6502 Assembly Language.  Dit is een 16-bit processor die vaak is gebruikt voor consoles zoals de Commodore, Apple I, Acorn etc. De taal is een low level language, omdat de normale mens het niet kan lezen, maar computers wel. Assembly language gebruikt het hexadecimale stelsel in plaats van het decimale getallenstelsel. Het getallenstelsel dat wij gebruiken in ons stelsel zijn 0 tot en met 9, maar bij het hexadecimale getallenstelsel is het van 0 tot en met 9 en daarna komt A tot en met F. ‘F’ is dus 15 in het ‘normale’ getallenstelsel.   Wat wij vooral nodig hebben zijn de opcodes van assembly. Een opcode is een stukje code die specifiek zegt welk deel van de code bewerkt moet worden. Datgene waar de opcode de waarde verandert, heten operanden. Dit zijn alle opcodes die assembly gebruikt en ik zal kort uitleggen wat elke doet. 

`ADC`, ADd with Carry: Dit voegt de eerste 2 operands toe en de Carry Flag (`CF`)

`AND`, bitwise AND with accumulator: heeft een operand gepaard met accumulator en stopt het weer terug in de accumulator 

`ASL`, Arithmetic Shift Left: verplaatst de byte van bijvoorbeeld de eerste plaats naar de laatste plaats in de RAM 

`BRA`, BRanch Always: je kan de volgorde van instructies bepalen

`BRK`, BReaK: veroorzaakt een interrupt waardoor de program counter omhoog gaat

`CMP`, CoMPare accumulator: zoals het al zegt vergelijkt het 2 values (door ze van elkaar af te halen)

`CPX`, ComPare X register: Werkt hetzelfde als CMP

`CPY`, ComPare Y register: Werkt hetzelfde als CMP

`DEC`, DECrement memory: je verlaagt de waarde 1

`EOR`, bitwise Exclusive OR: vergelijkt de bit van de eerste operand met de eerste bit van de tweede operand. 

`INC`, INCre: hoeveel van de value wordt toegenomen met memory 

`JMP`, JuMP: springt (letterlijk en figuurlijk naar de volgende address) 

`JSR`, Jump to SubRoutine, springt naar de stack voordat hij verder gaat 

`LDA`, LoaD Accumulator: van het geheugen naar accumulator en houdt daar alle data vast

`LDX`, LoaD X register: Werkt hetelfde als `LDA` maar als je grens hebt overschreden wordt het een extra page. 

`LDY`, LoaD Y register: werkt hetzelfde als `LDX`

`LSR`, Logical Shift Right: elke bit verschuift 1 naar rechts

`NOP`, No OPeration: ruimte dat is overgehouden voor opcodes die later erin kunnen worden gezet 

`ORA`, bitwise OR with Accumulator: zet een keuze op bij de accumulator bijvoorbeeld waar of niet waar

`ROL`, ROtate Left: elke bit verschuift eentje naar links

`ROR`, ROtate Right: elke bit verschuift eentje naar rechts

`STA`, STore Accumulator: dit is waar de values worden bewaard. Voor een `STA` is altijd een `LDA`. Dit zal van te pas komen bij het maken van cheat codes.

`STX`, STore X register: specifieke versie van `STA` in RAM

`STY`, STore Y register:zelfde als `STX` 


# Bonvermelding 

1) 1wErt3r, (2012), ‘A Comprehensive Super Mario Bros. Disassembly’
Geraadpleegd op 16 Juni 2023 via https://gist.github.com/1wErt3r/4048722
2) ‘6502 Assembly’ geraadpleegd op 16 juli 2023 via 
https://en.wikibooks.org/wiki/6502_Assembly

3) ‘Codemasters’ Geraadpleegd op 19 september 2023 via  
https://nintendo.fandom.com/wiki/Codemasters

4) ‘FCEUX’ geraadpleegd op 10 juli 2023 via https://fceux.com/web/home.html

5) Fernando, Jason, (2023), ‘Assembly Language’ 
Geraadpleegd op 18 september 2023 via https://www.investopedia.com/terms/a/assembly-language.asp#:~:text=An%20assembly%20language%20is%20a,to%20be%20readable%20by%20humans

6) ‘Game Genie’ Geraadpleegd op 19 september 2023 via 
https://www.nesdev.org/wiki/Game_Genie#:~:text=The%20Game%20Genie%20is%20a,game%20to%20be%20inserted%20into

7) ‘game genie (instructions only)’ Geraadpleegd op 18 september 2023 via https://www.digitpress.com/library/manuals/nes/game%20genie%20(instructions%20only).pdf

8) Gryphon, Kaden, Ven, (2022), ‘Teaching Assembly Programming Through Video Games’
Geraadpleegd op 15 juli 2023 via 
https://louis.uah.edu/cgi/viewcontent.cgi?article=1703&context=honors-capstones

9) Kent, S.L., (2001) The Ultimate History of Video Games, Roseville, California

10) Morgan, Nick, (2015), ‘Easy 6502’
Geraadpleegd op 15 juli 2023 via https://skilldrick.github.io/easy6502/

11) Pickens, John, (2020), ‘NMOS 6502 Opcodes’
Geraadpleegd op 18 september 2023 via http://www.6502.org/tutorials/6502opcodes#DFLAG

12) Realemulator101, ‘6502 Addressing Modes’, Geraadpleegd op 20 september 2023 via http://www.emulator101.com/6502-addressing-modes.html

13) Reddit en Discord  Geraadpleegd op 20 november 2023 

14) Selwyn, Kevin, (2019), ‘Game Genie Disassembly’
Geraadpleegd via https://www.kevinselwyn.com/posts/game-genie-disassembly/

15) Silverberg, David, (2020), ‘Game Breaking: How Cheat Codes Changed Video Games Forever’
Geraadpleegd op 15 september 2023 via https://www.popularmechanics.com/culture/gaming/a33650224/cheat-code-history/

16) ‘Super Mario Bros.:RAM map’ Geraadpleegd op 21 september 2023 via https://datacrystal.romhacking.net/wiki/Super_Mario_Bros.:RAM_map

17) The Might Mike Master, ‘NES Game Genie Technical Notes’
Geraadpleegd op 15 september 2023 via 
https://tuxnes.sourceforge.net/gamegenie.html
























![Rundown of Making the Game Genie Code 'NYSUZSZE'](https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/265fb032-d0c3-466b-942c-8215164a5d1d)

https://github.com/18gssidhu10/18gssidhu10.github.io/assets/151066156/dfa6c364-13e6-4f1d-a60a-655dee559eb3

